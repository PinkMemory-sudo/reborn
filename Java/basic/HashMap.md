* 数据结构
* 扩容
* 性能



* 排序
* 各自的优缺点
* 各自的数据结构
* 存取原理
* java7和Java8中的区别
* 为什么会线程不安全？有什么解决办法
* hash的计算规则，怎么解决hash碰撞



* 数据结构
* 优缺点
* 适合通过下标访问





# Collections



## List

* 有序的（存取顺序一致）
* 可重复的，允许有null值



### ArrayList

* 线程不安全
* 随机访问

**数据结构**

底层使用的是Object数组，当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。

**扩容**

默认初始容量为10，每次add[All]时，将当前元素个数+添加的元素个数，大于当前的容量时，就会调用grow进行扩容。新的长度=就的长度的1.5倍，然后跟需要的个数比较，取最大的，随后判断是否超过MAX_ARRAY_SIZE，通过Arrays.copyOf创建一个新数组，再添加元素。





### LinkedList

* 线程不安全
* 有专门针对头尾的操作

数据结构



**扩容**

链表扩个屁容





## Set

* 无序
* 不可重复



### HashSet



数据结构：

HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个固定对象，add方法调用的是底层HashMap中的put()方法。



### LinkedHashSet

LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。

LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)LinkedHashSet需要维护元素的插入顺序



### TreeSet







# Map



## HashMap

默认长度16

负载因子0.75

put方法：

取key的hash(null的hash为0)

hash方法:高16位不变，底16位与高16为进行异或，目的是为了减少碰撞，因为计算下标的时候(length-1)$hash,只有底为参与了运算



## LinkedHashMap

继承了HashMap，在HashMap的基础上增加了链表，保证了键值对插入顺序先



## TreeMap

红黑树，根据对象实现的compatrable或者提供一个comparator实现排序。

TreeMap底层实现了红黑树



树->二叉树->二叉查找树->平衡二叉树->红黑树

红黑树利用节点的颜色来维持平衡(任意节点到叶子节点经过的黑色的节点的数量相同)节点插入时会赋为红色/黑色

红黑树满足一下几个条件：

* 根节点是黑色
* 叶子节点是黑色
* 一个节点如果是红色，则它的子节点都是黑色
* 任意节点到它的叶子节点左右经过的黑色的节点的数量相同



**HashMap**

？

* HashMap的扩容机制，负载因子
* 默认初始化容量为什么是16
* 为什么容量总是2的幂



由数组和链表组成，1.8添加了红黑树，将时间复杂度降到了O(logn)

put时根据key的hash计算出一个index



Node

每个Node都保存了自身的hash,key,value及下一个Node



新节点插入链表时是怎么插的？

1.8之前是头插法，作者认为后插入的被查询的可能性大，1.8之后改成了尾插法



## **扩容机制**



* 1.7和1.8的区别

数据结构：1.7是数组+链表，1.8之后是数组+链表+红黑树



流程：添加元素是判断是否需要扩容 -> 生成新数组(两倍) -> 根据新容量重新计算每个元素的下标转移到新数组



**1.7扩容的缺点**



数组的容量是有限的，当达到一定数量时就会进行扩容。

1. 创建一个新的空数组，长度是原来的2倍
2. 遍历原来的数组，重新hash到新数组中(因为长度变化后，hash规则也随之发生了变化)



index = HashCode（Key） & （Length - 1）

**之所以用位与运算效果与取模一样，性能也提高了不少**

取模和与运算的关系：与n取模就是与(n-1)做与运算



**为什么变成了尾插法**

**使用尾插**，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了



**HashMap的初始容量为什么是16？**

怎么尽可能的得到一个均匀分布的hash呢？





**容量为什么建议是2的幂？**

`X % 2^n = X & (2^n – 1)`

只要保证长度是2的n次方就可以通过与

`x/8=X>>3`



**HashMap如何保证容量一定是2的幂的？**

我们指定的初始容量，HashMap会计算出来一个值作为初始容量

计算过程：





**扩容因子**

设置成0.75的好处是与容量相乘，得到的都是整数



**重写equals方法的时候需要重写hashCode方法呢？**

Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。

对于值对象，==比较的是两个对象的值。对于引用对象，==比较的是两个对象的地址。

通过key的HashCodo来计算出index，怎么才能找到key呢。

**equals**！所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。



**HashMap的线程安全问题**

存在线程不安全的场景时可以使用CorruentHashMap，HashTable的并发度太低。

HashTable直接在方法上加锁，currentHashMap就好很多了



**HashMap在JDK1.7中为什么会出现死循环？**

扩容时，需要将旧表中的数据迁移到新表中，使用的是头插法，会使链表的顺序反转(这是出现死循环的关键点)



**HashMap为什么线程不安全？**

jdk1.7在多线程不断进行put的情况下HashMap容器出现死循环。



**Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表?**



**HashTable**

HashTable不允许null，在put时就会失败





# Iterable接口

被Collection所继承，所以是Collection通用的遍历方法。

**什么是迭代器？**

就是通过hasNext()来判断有没有元素，通过next取出元素，不用管底层的数据结构和实现原理。



# 快速失败机制



对个线程对集合进行改变是就可能触发fail-fast机制



# 红黑树



每个节点到叶子节点所经过的黑色的节点的个数都一样























# ConcurrentHashMap



**分段锁**

支持 CurrencyLevel (Segment 数组数量)的线程并发
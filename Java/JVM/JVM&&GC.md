# JVM



## JVM内存划分

![1634477474228](../../img/JVM内存划分2021-10-17 213127.png)



* 都存放什么

* 有什么作用



**直接内存**

非运行时数据区的一部分，其他的都是运行时数据区。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部 分内存也被频繁地使用



### 线程共有的



**堆**

用来存放实例，几乎所有的对象实例都存在堆里，堆时JVM内存管理的核心区域，

JVM中堆是最大的一块内存空间，所有线程共享的一块区域，在虚拟机启动的时候创建。堆还可以细分，详情看GC部分。随着JIT编译期的发展与逃逸分析技术逐渐 成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐 变得不那么“绝对”了。

从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被 返回或者未被外面使用(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。



**方法区**

存储已被虚拟机加载的类信息，常量，静态变量等。方法区也称为永久代。常量池是方法区的一部分

jdk1.8取消了方法区，用元空间代替。



### 线程私有的

**程序计数器**。

记录着当前线程正在执行的字节码的地址，线程切换后根据程序计数器能恢复到正确的执行位置。



**虚拟机栈**

保存着栈帧，描述方法执行的内存模型，。每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

**栈帧**：存放着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等 。 

**局部变量**：表存放着编译期可知的各种数据类和对象的引用

**操作数栈**：

**动态连接**：

Java虚拟机栈可能会出现两种错误：StackOverFlowError 和 OutOfMemoryError

***StackOverFlowError*** : 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈 的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

***OutOfMemoryError*** : 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多 内存的话。就会抛出 OutOfMemoryError 错误。



**本地方法栈**

与虚拟机栈相似，但是本地方法栈执行的是native方法。在hotspot虚拟机中本地方法栈和Java虚拟机栈合而为一。



## JVM常用命令

jps

jinfo

jstat

jstack

jmap



# GC



[参考](https://www.cnblogs.com/czwbig/p/11127159.html)

 Java 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭 , 而 Java 堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。 



## 如何判断哪些对象应该被回收

两种判断方法：引用计数法和可达性分析



**引用计数法**

 给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效。

缺点：无法解决对象之间相互循环引用的问题。 

**可达性分析**

通过一些列称之为“GC Roots” 的对象作为起点；从此起点向下搜索，所走过的路径称之为引用链，当一个对象到 GC Roots 没有任何引用链相连接，代表此对象不可达。 

对象判定为不可达后不会立即被GC，至少要经过两次的标记。



**GC Roots**

* 虚拟机栈中引用的对象
* 方法去中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法中JNI(Native)引用的对象



**强软弱虚引用**

***强引用：***我们使用的基本都是强引用，不会被GC，即使OutOfMemory

***软引用：***可有可无的对象，如果空间足够就不会GC它。只要垃圾回收器没有回收它， 该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。

***弱引用：***与软引用不同的时GC时不管内存够不够，如果只有弱引用，就会被GC。

***虚引用：***相同虚设，跟没有引用一样，随时可以被GC，  **无法通过虚引用来取得一个对象实例** 。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 

虚引用主要用来跟踪对象被垃圾回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。虚引⽤必须和引⽤队列（ReferenceQueue）联合使⽤。





## **内存的分配和回收**

Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。

由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为:新 生代和老年代:再细致一点有:Eden 空间、From Survivor、To Survivor 空间等。



**新生代**

大部分情况，对象都会首先在 Eden 区，当 eden 区没有足够空间进行分配时，直接进入老年代。

在一次新生代垃圾回收后，如果对象还存活，则 会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)， 当它的年龄增加到一定程度(默认为 15 岁)，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

经过一次GC后，经过这次 GC 后，Eden 区和"From"区已经被清空。"From"和"To"会交换他们的⻆ 色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"



## 垃圾收集算法



**标记清除法**

标记处要清除的所有对象，然后将所有的标记对象清除。

弊端：造成了地址空间的不连续，造成内存碎片。



**复制算法**

将内存分成两部分，将存活下来的对象移动到另一半，然后清除，最后左右互换。

8:1:1，由于新生代中大部分对象都是"朝生夕死",并不需要完全分成两部分，而是分成Eden和Surivival。Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上 ，这样之浪费了10%的空间。

弊端：可用内存减少了一半



**标记整理**

再标记完之后，不是直接清理，而是将存活下来的对象先移动到另一端，然后再清理，这样就不需要分成两半了。

弊端：提高了空间利用率，但是移动增加了开销。



**分代收集算法**

根据对象所处生命周期划分为不同的几个空间，一般分为新生代老年代和永久代。

* 新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少。

* 老年代的特点是对象的存活率高，没有额外的内存给它担保，一般使用的是标记清除和标记整理算法(浪费的空间少)。



## 垃圾回收器



**Serial**

采用单线程进行垃圾回收，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程，直到它收集结束。

新生代采用赋值算法，老年代采用标记整理算法。

Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。



**ParNew**

就是Serial的多线程版本，它是许多运行在 Server 模式下的虚拟机的首要选择。
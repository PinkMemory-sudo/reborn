* 多线程的使用，并发编程
* MQ的使用

# BEGIN

自我介绍：

学校，专业，工作经历，项目经历。

自己负责的模块：流程讲清楚，技术亮点说出来(多线程，分布式，中间件，自定义注解，设计模式，经过了几个服务)

* 并行流

* 失败机制

* 重试机制

* 幂等机制，解决幂等性问题就是添加业务ID，判断业务ID是否已经处理过

* 线程池的核心参数

* 

  **生产问题**

  

  * 问题
  * 原因
  * 发现手段
  * 解决方案



**日志规法**



# Java

Hashmap原理

HashMap扩容

ArrayList的扩容

线程安全的hashmap

头插法尾插法

容量为什么是2的幂次方

ConcurrentHashMap

JMM

CopyOnWriteArrayList

volatile

synchronized



AQS

[参看](https://www.cnblogs.com/jimoer/p/13747291.html)

AQS中提供了操作state的方法：

- getState();
- setState();
- compareSetState();

以及具体线程在等待队列中的维护（获取资源入队列、唤醒出队列等），AQS已经实现好了。只需要我们重写获取与释放。



lock与synchronized

synchronized 和 ReentrantLock 默认都是非公平锁，当然我们在创建 ReentrantLock 时，可以手动指定其为公平锁，但 synchronized 只能为非公平锁。

首节点/CAS



**什么是公平与非公平**

公平锁： 指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 非公平锁： 多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。



**原子操作类**

基本类型

引用类型

数组类型：更新数组compareAndSet

属性更新器类型：



**怎么唤醒阻塞的线程**

 timewaiting,waiting,block 都是可以认为阻塞线程

阻塞原因



**如何停止正在运行的线程**



**线程的状态**



**线程发生异常时会怎样**

线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部，父线程感知不到也捕获不到子线程的异常

java为我们提供了一种线程内发生异常时能够在线程代码边界之外处理异常的回调机制，即Thread对象提供的setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法。



**ThreadLocal原理场景内存泄漏**

[参考](https://juejin.cn/post/6932807532587810824)

![image-20231112123901570](..\image\image-20231112123901570.png)

![image-20231112124154168](..\image\image-20231112124154168.png)

![image-20231112124435897](..\image\image-20231112124435897.png)

interrupted



join yield

join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。

yield让出CPU执行权只是使当前线程重新回到可执行状态



**callable与runnable的区别**

* 返回值
* 异常：run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口call 方法允许抛出异常，可以获取异常信息



submit() 和 execute()方法有什么区别？

![image-20231112125144282](..\image\image-20231112125144282.png)



ReentrantLock怎么实现可重入的

[参考](https://blog.51cto.com/u_16097317/6933447)



并发容器

![image-20231112130534189](..\image\image-20231112130534189.png)



**JVM内存划分**

[参考](https://juejin.cn/post/6935417287990050846)



类加载过程

[参考](https://www.woshinlper.com/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/)



**双亲委派**

[参考](https://www.51cto.com/article/745615.html)



都有哪些垃圾回收算法

* 标记清除： ⾸先标记出所有不需要回收的对象，在标记完成后统⼀回收掉所 有没有被标记的对象。 造成了内存碎片
* 复制算法： 以将内存分为大小相同的两块，每次使⽤其中 的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。浪费了一半内存。
* 标记整理：标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。移动增加了开销。
* 分代收集：般将 java 堆分为新⽣代和⽼年代，每个代使用不同的算法。



**如何判断一个对象应该回收，哪些对象可以作为GC Root**

[参考](https://www.yisu.com/zixun/445314.html)



老年代为什么使用标记整理和标记清除，新生代为什么要使用复制算法

[参考](https://www.kuangstudy.com/bbs/1327624514502131713)

# web



**支付宝的接口调用**



**session和cookie的区别**

* cookie保存在浏览器，session保存在服务器，session的安全性要大于cookie，通常使用Cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果有sessionid，服务器将根据该id返回对应Session对象。如果客户端请求中没有sessionid，服务器会创建新的Session对象，并把sessionid在本次响应中返回给客户端。
* session没有大小的限制



**接口调用的失败机制，重试机制，幂等机制**



**解决过的生产问题**



# 分布式



防止重复请求(幂等问题)

Hystrix 熔断原理，为什么用熔断

Feign 通信原理

负载均衡策略，以及Ribbon原理

zuul四种过滤器原理

注册中心Rureka流程解释

**SpringCloud限流用那个组件**

**什么是微服务**

**分布是的优点**

哪个用到的多哪个就多部署一点

**分布式的缺点**

1、架构设计变得复杂，事务不好处理（分布式事务）

2、部署服务复杂话，启动需要很久

3、系统的吞吐量会变大，但是响应时间会变长

5、架构复杂导致学习曲线变大

6、测试和查错的复杂度大，因为链路太长环境太多，需要花时间定位具体在什么服务上在物理在什么机器上

8、最麻烦的是消息不知道落地哪台机器上了，大公司有分布式日志框架来解决这个问题TraceID 

**分布的组件**

微服务有什么优缺点





# WEB



**session的实现方式(分布式session)**







# NET



**HTTP的状态码**

* 500
* 401
* 302



**为什么要进行三次握手和四次挥手，详细点**



`bn

**浏览器输入URL 整体流程-包括网络层、链路层、物理层**



**DNS解析原理**



# 设计模式



模板模式



**单例模式分类**

怎么实现单例设计模式，饿汉式，懒汉式



**模板模式**

模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。

使用场景

* 固定算法骨架
* 各个子类中有公共的部分
* 需要控制子类情况，扩展留给子类
* 一般Controller类某功能的增删改查

写好固定的处理逻辑



## 算法



**你知道的排序方法有哪些，时间复杂度**











# MySQL











# Spring



**IOC/AOP原理**

在Spring里面，主要提供了 BeanFactory 和 ApplicationContext 两种 IOC 容器，通过他们来实现对 Bean 的管理。



**自动装配原理**



**Spring中使用了哪些设计模式**



**Spring AOP 和 AspectJ AOP 有什么区别**

Spring AOP 基于动态代理的方式实现，如果是实现了接口的话就会使用 JDK 动态代理，反之则使用 CGLIB 代理.

AspectJ 则属于编译时增强，主要有3种方式：



**JDK 动态代理和 CGLIB 代理有什么区别**

JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。他基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。

而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。他的底层原理是基于 asm 第三方框架，通过修改字节码生成成成一个子类，然后重写父类的方法，实现对代码的增强。



**FactoryBean 和 BeanFactory 有什么区别**

BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。

FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。



**SpringBean 的生命周期**

实例化，属性赋值，初始化，销毁

扩展接口：

* Aware
* BeanPostProcessor接口提供两个方法，
* 如果配置了init-method方法，则会执行init-method配置的方法

* 容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法



**Spring 事务传播机制有哪些**

1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这也是通常我们的默认选择。

2.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

3.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。

4.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

5.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

6.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

7.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。



**Spring事务失效的原因**



**Spring 是怎么解决循环依赖的**

前提：

1. 不是构造器注入的循环依赖
2. 单例

三级缓存：

* 第一级：用来保存实例化、初始化都完成的对象
* 第二级：实例化但没初始化的对象
* 第三季：保存对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象

假设AB循环依赖

1. 创建A时，把A的工厂放到三级缓存
2. 发现依赖B，就去创建B，发现依赖于A就从一级缓存开始找B，从三级缓存中获得工厂拿到A，然后将A放入二级缓存，删除A的三级缓存，将B放入一级缓存
3. 接着创建A，A从一级缓存中拿到B，将删除A的二级缓存放入一级缓存



**为什么要三级缓存？二级不行吗**



**Spring Boot 启动流程吧**



**SpringMVC流程**



# Redis



**Redis为什么快**

* 基于内存
* 当年线程，没有上下文切换
* 多路IO复用
* 对多种数据类型的优化(字符串，调表)



**Redis6.0 之后又改用多线程**

只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。



**热 key 问题怎么解决**

所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。

1.提前把热key打散到不同的服务器，降低压力

2.加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询



**缓存击穿、缓存穿透、缓存雪崩**

1.加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了





**Redis 的过期策略有哪些**

惰性删除：如果一些key不使用就无法删除

定期删除：每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。



**定期+惰性都没有删除过期的 key 怎么办**

走到redis的内存淘汰机制



**持久化方式有哪些？有什么区别**

**RDB**

SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。

BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。

**AOF**

```
always ##aof_buf内容写入并同步到AOF文件
everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步
no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定
```

always ##aof_buf内容写入并同步到AOF文件
everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步
no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定



**怎么实现 Redis 的高可用**









## 多线程的优势与存在的风险

**优势**

* 提高计算速度(CPU利用率)，减少响应时间，提高吞吐量



**风险**

* 多线程操作共享资源，处理不好可能会存在数据不一致问题(丢失数据，数据覆盖等问题)
* 线程活性问题：
  * 死锁 ，鹬蚌相争
  * 锁死(依赖挂了)
  * 活锁
  * 饥饿：一些线程总能抢到资源，其他线程抢不到
* 上下文切换
* 可靠性



## JMM Java内存模型

[参考](https://zhuanlan.zhihu.com/p/29881777)



Java变量可能读到了主  内存，缓存或者寄存器中。共享变量读取到不同处理器的寄存器上，产生可见性问题。

![1638114632951](E:\note\languages\note\img\1638114632951.png)



![1638114843256](E:\note\languages\note\img\1638114843256.png)

Java Memory Model

与CPU类似，CPU不直接从内存中读取数据，而是从内存读到Cache再到寄存器，Cache和寄存器都是CPU独有的，相互之间不能读取，就出现可见性问题了。



![1638115983908](E:\note\languages\note\img\1638115983908.png)



每个线程都有自己的栈空间，里面存放着方法和局部变量，都共享堆空间中的对象。而对于硬件来讲，没有什么堆和栈空间，所有东西都存在主内存，一些数据可能会存在Cache或Register中。CPU在读取变量时需要从主内存读到Cache，Cache再读进寄存器，一个CPU不能访问另一个CPU的寄存器，所以它们同时读取一个数据时，一个CPU更改另一个CPU却也在之前的数据上进行修改，看不见另一个CPU的修改，造成不可见性。

一个CPU的告诉缓冲器可以通过缓存一致性协议读取另一个缓存的数据更新到自己的缓存，这样保证可见性，为了保证可见性，必须将操作结果刷新到Cache中。



我们将这个模型抽象化，用来屏蔽掉各种硬件和操作系统的内存访问差异，帮助我们理解一个线程如何以及合适可以看到其他线程堆共享变量的修改结果，如何同步的访问共享变量。



* 共享变量存入主内存中
* 每个线程都有一个私有的本地内存(工作内存)，抽象的概念，并不是真正存在的(包含了Cache，Register等)，本地内存中存储这共享变量的副本，线程不直接操作共享变量，而是在副本上进行操作。各自的副本是独有的,其他线程不可见。



**JMM下的线程间通信**

本地内存都是不可见的，所以JMM下的线程通信必须经过主内存。



规定：

* 每个线程之间的共享数据存储再主内存中
* ，类比CPU
* 每个线程从主内存中包数据读取到工作内存，保存副本进行处理，对其他线程不可见



JMM并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。



CPU执行速度很快，而内存到CPU读写数据相对来说比较慢，就出现了CPU高速缓存。运行时先将需要的数据从内存复制一份到告诉缓冲中，然后再写入寄存器。CPU直接从寄存器中读取数据，运行完之后再将高速缓冲中的数据刷入寄存器。

单线程运行时没什么问题，但是在多线程的运行中，一个线程复制到告诉缓冲区中后进行了修改，在还没有刷回内存时另一个线程有将内存中的数据刷入告诉缓冲区进行计算，这时已经不一致了，读取的实际是旧的。

解决缓存不一致问题一个做法是加锁，只能有一个线程对变量进行操作，刷回内存后才能被其他线程操作。锁住的是变量所在的内存地址，其他线程读取不了。这种做法导致了效率降低，有可能其他线程只是读取，并未要进行修改。这时就出现了缓存一致性协议：当CPU在曹硕共享变量时，会发出信号使该变量的缓存都失效，重新读取该变量。



**指令重排序**

处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序(单线程)最终执行结果和代码顺序执行的结果是一致的。对单线程而言：**貌似串行语义**。并不能保证多线程执行的结果。

**存储子系统重排序**

* LoadLoad重排序，一个处理器执行两个load操作L1,L2，另一个线程感知到的可能是L2,L1
* StoreStore重排序，一样的内存感知顺序反了
* LoadStore
* StoreLoad





**多线程要想正确执行，必须保证原子性可见性和有序性**



**原子性**: 

* 不可分割,在其他线程看来，要么还没执行，要么已经执行完了，其他线程看不到中间的执行结果
* 访问同一组共享变量时多个线程之间是不能交叉的

Java有两种方式来实现原子性：使用锁和利用处理器的CAS指令。锁具有排他性，同一时刻只能被一个线程访问，CAS是从硬件方便实现的。

**可见性**: 

一个线程修改共享变量后应该让其他线程都能看到。

**有序性**



定义一个类，包括它的资源，和它对资源的处理方法，这样就可以通过调用它的方法来处理它的资源。



多线程，资源很大，我自己调用它的方法比较慢，能不能多个人同时使用这个方法进行操作。



线程和线程执行的任务是分开的，我们写的实际就是线程执行的任务。

1. 实现Runnable或者继承Thread
2. 创建多个线程共同执行这个任务



有一堆任务需要一个个执行,每个任务需要执行10分钟

```java
@Slf4j
public class ThreadTask extends Thread {

		List<Integer> taskParamList;

    public ThreadTask(List<Integer> taskParamList) {
        this.taskParamList = taskParamList;
    }

    public void sale() {
        while (taskParamList.size() > 0) {
            try {
                TimeUnit.MINUTES.sleep(100);
                taskParamList.remove(taskParamList.size() - 1);
            } catch (InterruptedException e) {
                log.error(e.getMessage(), e);
            }
        }
    }
}
```



能不能让多个任务同时执行？

继承Thread，然后将这个任务分给多个线程


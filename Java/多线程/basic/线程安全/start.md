# 线程同步









线程同步机制：

用来协调线程之间的数据访问机制。



## 锁



**Basic Concept**

***临界区***：线程在拿到锁之后，释放锁之前所执行的代码被称为临界区(Critical Section)。

***排他锁***：排他锁(Exclusice)又称为互斥锁(Mutex)，同一时间只能被一个线程持有。

***内部锁和显示锁***： 内部锁通过synchronized关键字实现，显示锁通过java.concurrent.locks.Lock接口实现



通过锁可以保证线程的原子性可见性和有序性。

锁通过互斥保证**原子性**，一个锁只能被一个线程持有，保证了临界区的代码一次只能有一个线程执行，将多个线程对共享数据的并发访问转换为串行的访问。

**可见性**通过刷新处理器的缓存实现，锁的获得和释放隐含着冲刷处理器缓存的动作。

**有序性**：临界区只有一个线程执行



**锁的粒度**： 保护的共享数据的数量的大小

**锁的分类：**

公平/非公平

可重入/不可重入

独享/共享

互斥/读写

乐观/悲观

偏向/重量/轻量

自旋锁



**公平锁**

公平锁是指多个线程按照申请锁的顺序来获取锁

**非公平锁**

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于`Java ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

对于`Synchronized`而言，也是一种非公平锁。由于其并不像`ReentrantLock`是通过`AQS`的来实现线程调度，所以并没有任何办法使其变成公平锁。

**可重入锁**

一个线程在持有该锁的时候，能否再次申请该所。广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。`ReentrantLock`和`synchronized`都是可重入锁

比如

```java
synchronized void setA() throws Exception{
   Thread.sleep(1000);
   setB();
}
synchronized void setB() throws Exception{
   Thread.sleep(1000);
}
```



**独享锁**：该锁每一次只能被一个线程所持有。

**共享锁**：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。



# 锁的状态

* 无锁状态
* 偏向锁状态
* 轻量级锁状态
* 重量级锁状态

四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。

**这四种状态都不是Java语言中的锁**，而是Jvm为了提高锁的获取与释放效率而做的优化(**使用synchronized时**)

**偏向锁**

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级**

轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

















# 线程之间的通信



## wait/notify

A线程依赖B线程，A线程在运行时B还没准备好，A就需要等待，B准备好时把A唤醒。

线程A需要一个条件，不满足时就等待，B修改了条件后使得条件满足时唤醒A。



### **wait**

使当前线程

**注意：**调用wait前必须先获得锁，调用wait后会立即释放锁。进入阻塞状态。

**使用wait的伪代码**

```java
synchronized (锁对象){
    while(条件不成立时){
        锁对象.wait();
    }
}
```



**wait(long)**

超时时自动唤醒



### **notify**

唤醒其中一个线程，也必须在同步代码块中使用锁对象调用，调用后并不会立即释放锁对象，需要将同步代码块执行完。

**伪代码**

```java
synchronized (锁对象){
    锁对象.notify();
}
```





**IlegalMonitorStateException**

没有使用锁对象调用wait和notify时会出现异常



**interrupt()**

线程处于wait状态时，通过调用线程的interrupt()，会中断阻塞状态，然后抛出intertuptedException异常，所以后面的代码不会再执行，而是进入异常捕获。



**同步代码块中释放了锁**

唤醒后需要重新判断，***将if语句转为while***



**通知过早**

在调用wait()之前就调用了notify，导致信号丢失。添加标志，wait时判断一下是否需要wait





















## join



## ThreadLocal

* 线程
* 线程池
* 锁
* 并发容器
* 原子操作类
* 线程池
* 面试题
* 上下文切换
* 死锁，原因，怎么避免
* 时间片调度
* 无锁并发编程
* CAS算法
* 

volatile：如何保证可见性的

将当前处理器缓存行的数据写回到系统内存。 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

内存模型

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2或其他)后再进行操作，但操作完不知道何时会写到内存



缓存一致性协议：保证各个处理器的缓存是一致的

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当 处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状 态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里



启动和终止线程



为什么使用多线程？什么情况下适合多线程？使用多线程会带来哪些问题？

计算密集型的用多线程执行反而效率低，因为线程的创建和上下文切换的开销，此外，影响性能的还可能是网络，IO等其他原因



**并发机制的底层原理**

依赖于JVM的实现和CPU指令



原子性，有序性，可见性

**Synchronized**

三种用法的锁

锁在哪里？里面有什么信息？

同步方法和同步代码块实现原理？

代码块同步是使用monitorenter 和monitorexit指令实现的,monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结 束处和异常处,任何对象都有 一个monitor,线程执行到monitorenter 指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁.

**对象头**

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位

Synchronized锁升级

**偏向锁**

在无竞争的情况下减少同步的开销

加锁：当一个线程第一次获取锁时，锁对象的标记字段会记录下当前线程的 ID，表明该线程“偏向”于这把锁。如果之后这个线程再次进入同步块，不需要进行任何同步操作，也不需要使用原子指令来加锁解锁，因为它已经“偏向”该锁。

释放：直到其他线程尝试获取该锁，偏向锁才会被撤销，锁会升级为轻量级锁或重量级锁

偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活

**轻量级锁**

用于解决多个线程偶尔竞争同一锁的情况

加锁：

* 当线程尝试进入同步块时，JVM 会首先在栈帧中为这个线程创建一个锁记录（Lock Record）如果锁对象是无锁状态（即偏向锁已经撤销），线程会尝试通过 CAS 操作将锁对象的标记字段（Mark Word）更新为指向它的锁记录。如果成功，则获得轻量级锁

* 如果 CAS 操作失败，则说明有其他线程也在竞争锁，线程不会立即阻塞，而是通过自旋等待一段时间，轻量级锁会升级为重量级锁

解锁



**原子操作的实现**

CPU是怎么实现的

* 总线锁
* 缓存锁

Java是怎么实现的

* CAS：并发包，ABA问题，循环开销，只能保证一个共享变量的原子操作，AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对 象里来进行CAS操作
* 锁：



# **内存模型**

顺序一致性，final，

## 

**并发编程的两个关键问题**：线程的通信与同步

线程间同步机制有两种：共享内存和消息传递

JMM是一个抽象的概念


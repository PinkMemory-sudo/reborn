**什么是设计模式？为什么要使用设计模式？**

设计模式是解决一些问题的通用解决方案，为了减少烂代码，使代码更加容易复用和扩展(复用于解耦)



**学习路径**

了解每个设计模式的概念，使用场景，类和对象的关系

动手编程

项目中使用的设计模式

面试考点

UML(类与类之间的关系)画出设计模式核心角色



**哪些框架使用了什么设计模式？**



# **设计模式的原则**

**单一职责**

**接口隔离原则**（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

**依赖倒转原则**（Dependence Inversion Principle）

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

**里氏代换原则**（Liskov Substitution Principle）

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

**开闭原则**（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**迪米特法则**（最少知道原则）（Demeter Principle）

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。



# UML

是什么？

统一建模语言，用符号描述各个元素(接口、类、实现、泛化、依赖、组合、聚合)

![image-20221118075553290](..\image\设计模式-UML)

**依赖**：A需要使用B(是一种非常弱、临时性的关系,局域变量、方法的形参，或者对静态方法的调用，这种关系是临时性的，用完就解除了)

**关联**：是依赖关系更强的一种关系,关联关系一般表现为被关联类B以类属性的形式出现在关联类A中，知道另一个类的方法和属性。

**聚合**：聚合是一种特殊的关联关系，它是较强的一种关联关系，强调的是整体与部分之间的关系。代码层面与关联相同，只能从语义(has a)来判断。

**组合**：比聚合关系更强的关联。强调了整体与部分的生命周期是一致的，而聚合的整体和部分之间在生命周期上没有什么必然的联系。

**泛化**：继承

**实现**：A实现了B接口

![image-20221118081717364](C:\Users\11942\AppData\Roaming\Typora\typora-user-images\image-20221118081717364.png)



# 23种设计模式



**设计模式的分类**

创建型：怎么去创建对象

* 抽象工厂模式(Abstract Factory)
* 建造者模式(Builder)
* 工厂方法模式(Factory Method)
* 原型模式(Prototype)
* 单例模式(Singleton) 

结构型：处理类和对象的组合(组合、聚合、继承、实现等)

* 适配器模式(Adapter)
* 桥接模式(Bridge)
* 组合模式(Composite)
* 装饰模式(Decorator)
* 外观模式(Facade)
* 享元模式(Flyweight)
* 代理模式(Proxy)

行为型：类和对象的交互和职责分配



**重点**

* 单例模式（几种实现的手写：懒汉，饿汉，双检锁，静态内部类，线程单例，枚举，各个模式的优缺点）
* 工厂方法
* 建造者
* 适配器
* 装饰器
* 代理
* 策略
* 责任链
* 观察者
* 迭代器



![image-20221118073447774](C:\Users\11942\AppData\Roaming\Typora\typora-user-images\image-20221118073447774.png)

## 单例模式(Singleton) 

保证一个类只有一个实例，节省资源，对于需要频繁创建和销毁的对象可以提高性能，资源消耗多的，工具类对象，频繁访问数据库或文件的对象

实现方法：

* 双重检查
* 静态内部类
* 枚举

实现：

1. 构造器私有化
2. 一个私有变量来保存这个唯一的实例
3. 提供一个公共的获取对象的方法返回私有变量



**饿汉式**优缺点：

* 类装载时就完成实例化，**没有线程安全问题**
* 没有懒加载，如果一直没有使用就内存浪费了

**懒汉式**优缺点：

* 懒加载
* 存在线程安全问题

解决方案：

1. getInstance方法添加synchronized，缺点：效率低，每次获得实例都要加锁，实际实例初始化后可以直接拿
2. **双重校验**，解决了同步方法的效率问题，实例存在时直接返回，实例不存在时才加锁去创建实例

**静态内部类**

* 外部类状态的时候静态内部类并不会立即被装载，实现了懒加载

* 类装载机制保证初始化实例时只能有一个线程，保证线程安全

**枚举**

不仅解决了线程安全问题，而且还能防止反序列化时创建新的对象



# 工厂设计模式



获得不同子类



### 简单工厂

定义：也称静态工厂模式，直接将create变成静态的

创建一个类来获得不同的子类

场景：DateFormat

角色：工厂类，抽象产品，具体产品，通过工厂类获得不同子类

优点：解耦，类的创建过程与使用解耦

缺点：违背了开闭原则

在实现类少的情况下可以使用



### 工厂方法

也称工厂模式，

把类的实例化推迟到工厂子类

角色：

* 抽象工厂：规定创建产品的接口
* 具体工厂：实现抽象工厂，完成产品的创建
* 抽象产品：描述产品
* 具体产品：实现产品

优点：通过指定的工厂类创建对象而不是参数，新增工厂不去修改工厂代码而是新建工厂

缺点：



### 抽象工厂

打破了工厂和产品一对一的关系，一个工厂可以生产多种对象(即工厂不再是只有一个创建对象的方法而是对应多个)，没有特别大的区别

角色：

* 抽象工厂
* 具体工厂
* 抽象产品
* 具体产品



# 建造者模式



# 适配器模式



定义：将一个接口转换成另一个需要的接口，用来做兼容

角色：老接口，新接口，适配器(传入老接口，实现新接口)



想要实现了老接口的类当成新接口来用，可以增加一个适配器，将老接口通过构造方法传入，再实现新接口。



# 装饰器模式

定义：像一个现有对象中添加新功能

为了扩展功能，提供比更有弹性的替代方案，实现对扩展开放，对修改关闭。

实现：继承/关联

角色：

* 现有类，现有类的接口，装饰器类

装饰器类和现有类都实现一个接口，将现有类传入装饰器类。



# 模板模式

定义：定义好算法的接口，其中的几个步骤是可以替换的。

角色：

实现：通用步骤和算法在抽象类里实现，一些特殊的步骤在子类中实现。

优点：

缺点：





# 命令模式



# 状态模式



定义：类的行为随着状态而改变，看起来好像修改了类

使用场景：代码中包含了大量对象状态判断的

角色：

* 状态的抽象类：定义行为
* 状态实现类：实现行为，表示该状态对应的行为
* 环境类：状态的设置和执行该状态的行为

实现：将if-else的判断条件抽象出来，将**状态与行为绑定**

优点：减少了if-else

缺点：增加了类的数量





定义：

角色：

实现：

优点：

缺点：



# 策略模式



定义：一个类的行为/算法可以在运行时改变，根据不同环境选择算法。主要解决在多种相似算法的情况下使用if-else带来的复杂和难以维护性

使用场景：线程池的拒绝执行策略

角色：

* 策略
* 子策略
* 环境类

实现：

优点：算法随时切换，避免多重条件判断

缺点：增多了策略类，策略类需要对外暴露



**状态和策略模式的区别**

状态模式：根据不同状态采取不同的行为

策略模式：某一行为的具体执行



# 观察者模式

定义：对象之间的一对多依赖关系

角色：

* 观察者接口：定义通知方法
* 观察者：实现
* 发布者：实现添加观察者的方法和通知所用观察者的方法

实现：保存观察者的实例，当状态改变时调用实例的方法





# 迭代器模式

定义：不爆露底层原理的情况下便利集合中的所有元素，依赖导致原则

迭代器：是否有写一个元素，获得下一个元素



# 责任链模式

定义：将多个处理器串成链来处理一个请求

角色：

* 抽象处理类：一个保存下一个处理器的属性和处理请求的方法
* 包含一个方法和一个属性(保存下一个处理器)，方法用来处理请求，处理不了时调用下一个处理器进行处理

实现：

优点：请求与处理分离，请求者不需知道处理过程，提高系统灵活性

缺点：



# 面试题



**代理模式和适配器模式的区别**


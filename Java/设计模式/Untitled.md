* 复用代码
* 解耦，方便维护和扩展
* 复用经验，有些人已经解决过你的问题



原则：

把不变的和变化的区分出来，不影响其他部分

针对接口编程，而不是针对实现编程

**多用组合，少用继承**：，组合具有弹性

对扩展开放，对修改关闭

封装变化



策略模式



观察者

订阅， 取消订阅主题

对象之间一对多的依赖，一个对象发生改变时其他对象都会收到通知

角色：

主题接口：观察者列表，订阅，取消订阅主题，通知观察者

观察者接口：更新操作



**装饰器**

类爆炸

一个对象可以有多个其他的对象组成更强大的对象，比继承更弹性的扩展功能

装饰者和被装饰者实现同一个接口

角色：

装饰者：接口/抽象类

咖啡+配料



# 策略模式





# 状态模式



**定义**



**解决的问题(适用场景)**



**UML**

![image-20221211010940042](C:\Users\11942\AppData\Roaming\Typora\typora-user-images\image-20221211010940042.png)

**实现**

Context：用于维护状态实例，表示当前状态

State：定义

状态实现类



![image-20221211035403596](C:\Users\11942\AppData\Roaming\Typora\typora-user-images\image-20221211035403596.png)

**实现多个方法**

**相互关联**：状态里有Context用来修改当前的状态，Context中有状态用来将行为代理给状态执行



策略模式和状态模式

通过改变对象内部的状态类改变行为，状态不同，行为不同



当前状态对应的操作

设置下一个状态

状态图



状态机：有限状态机/有限自动机

首先找出所有状态，初始状态

找出所有动作，调用动作会改变对应的状态

一个实例变量来持有当前状态



State接口：封装一个状态对应的动作，每种状态都实现State接口



状态接口，状态类，状态机，状态机具体的执行委托给对应的状态对象



定义：允许对象内部状态改变时改变它的行为，对象看起来好像修改了它的类



通过修改状态来改变行为，对应的动作委托给状态对象



**状态模式和策略模式的区别**



？ 

状态如何改变，谁来维护的


* 多线程的使用，并发编程
* MQ的使用

# BEGIN

自我介绍：

学校，专业，工作经历，项目经历。

自己负责的模块：流程讲清楚，技术亮点说出来(多线程，分布式，中间件，自定义注解，设计模式，经过了几个服务)

* 并行流

* 失败机制

* 重试机制

* 幂等机制，解决幂等性问题就是添加业务ID，判断业务ID是否已经处理过

* 线程池的核心参数

* 

  **生产问题**

  

  * 问题
  * 原因
  * 发现手段
  * 解决方案



**日志规法**





# web



**支付宝的接口调用**



**session和cookie的区别**

* cookie保存在浏览器，session保存在服务器，session的安全性要大于cookie，通常使用Cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果有sessionid，服务器将根据该id返回对应Session对象。如果客户端请求中没有sessionid，服务器会创建新的Session对象，并把sessionid在本次响应中返回给客户端。
* session没有大小的限制



**接口调用的失败机制，重试机制，幂等机制**



**解决过的生产问题**



# 分布式



防止重复请求(幂等问题)

Hystrix 熔断原理，为什么用熔断

Feign 通信原理

负载均衡策略，以及Ribbon原理

zuul四种过滤器原理

注册中心Rureka流程解释

**SpringCloud限流用那个组件**

**什么是微服务**

**分布是的优点**

哪个用到的多哪个就多部署一点

**分布式的缺点**

1、架构设计变得复杂，事务不好处理（分布式事务）

2、部署服务复杂话，启动需要很久

3、系统的吞吐量会变大，但是响应时间会变长

5、架构复杂导致学习曲线变大

6、测试和查错的复杂度大，因为链路太长环境太多，需要花时间定位具体在什么服务上在物理在什么机器上

8、最麻烦的是消息不知道落地哪台机器上了，大公司有分布式日志框架来解决这个问题TraceID 

**分布的组件**

微服务有什么优缺点





# WEB



**session的实现方式(分布式session)**







# NET



**HTTP的状态码**

* 500
* 401
* 302



**为什么要进行三次握手和四次挥手，详细点**



`bn

**浏览器输入URL 整体流程-包括网络层、链路层、物理层**



**DNS解析原理**



# 设计模式



模板模式



**单例模式分类**

怎么实现单例设计模式，饿汉式，懒汉式



**模板模式**

模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。

使用场景

* 固定算法骨架
* 各个子类中有公共的部分
* 需要控制子类情况，扩展留给子类
* 一般Controller类某功能的增删改查

写好固定的处理逻辑



## 算法



**你知道的排序方法有哪些，时间复杂度**











# MySQL











# Spring



**IOC/AOP原理**

在Spring里面，主要提供了 BeanFactory 和 ApplicationContext 两种 IOC 容器，通过他们来实现对 Bean 的管理。



**自动装配原理**



**Spring中使用了哪些设计模式**



**Spring AOP 和 AspectJ AOP 有什么区别**

Spring AOP 基于动态代理的方式实现，如果是实现了接口的话就会使用 JDK 动态代理，反之则使用 CGLIB 代理.

AspectJ 则属于编译时增强，主要有3种方式：



**JDK 动态代理和 CGLIB 代理有什么区别**

JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。他基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。

而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。他的底层原理是基于 asm 第三方框架，通过修改字节码生成成成一个子类，然后重写父类的方法，实现对代码的增强。



**FactoryBean 和 BeanFactory 有什么区别**

BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。

FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。



**SpringBean 的生命周期**

实例化，属性赋值，初始化，销毁

扩展接口：

* Aware
* BeanPostProcessor接口提供两个方法，
* 如果配置了init-method方法，则会执行init-method配置的方法

* 容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法



**Spring 事务传播机制有哪些**

1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这也是通常我们的默认选择。

2.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

3.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。

4.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

5.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

6.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

7.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。



**Spring事务失效的原因**



**Spring 是怎么解决循环依赖的**

前提：

1. 不是构造器注入的循环依赖
2. 单例

三级缓存：

* 第一级：用来保存实例化、初始化都完成的对象
* 第二级：实例化但没初始化的对象
* 第三季：保存对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象

假设AB循环依赖

1. 创建A时，把A的工厂放到三级缓存
2. 发现依赖B，就去创建B，发现依赖于A就从一级缓存开始找B，从三级缓存中获得工厂拿到A，然后将A放入二级缓存，删除A的三级缓存，将B放入一级缓存
3. 接着创建A，A从一级缓存中拿到B，将删除A的二级缓存放入一级缓存



**为什么要三级缓存？二级不行吗**



**Spring Boot 启动流程吧**



**SpringMVC流程**



# Redis



**Redis为什么快**

* 基于内存
* 当年线程，没有上下文切换
* 多路IO复用
* 对多种数据类型的优化(字符串，调表)



**Redis6.0 之后又改用多线程**

只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。



**热 key 问题怎么解决**

所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。

1.提前把热key打散到不同的服务器，降低压力

2.加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询



**缓存击穿、缓存穿透、缓存雪崩**

1.加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了





**Redis 的过期策略有哪些**

惰性删除：如果一些key不使用就无法删除

定期删除：每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。



**定期+惰性都没有删除过期的 key 怎么办**

走到redis的内存淘汰机制



**持久化方式有哪些？有什么区别**

**RDB**

SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。

BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。

**AOF**

```
always ##aof_buf内容写入并同步到AOF文件
everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步
no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定
```

always ##aof_buf内容写入并同步到AOF文件
everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步
no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定



**怎么实现 Redis 的高可用**









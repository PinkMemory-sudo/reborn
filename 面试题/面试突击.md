* 多线程的使用，并发编程
* MQ的使用

# BEGIN

自我介绍：

学校，专业，工作经历，项目经历。

自己负责的模块：流程讲清楚，技术亮点说出来(多线程，分布式，中间件，自定义注解，设计模式，经过了几个服务)

* 并行流

* 失败机制

* 重试机制

* 幂等机制，解决幂等性问题就是添加业务ID，判断业务ID是否已经处理过

* 线程池的核心参数

* 

  **生产问题**

  

  * 问题
  * 原因
  * 发现手段
  * 解决方案



**日志规法**





# web



**支付宝的接口调用**



**session和cookie的区别**

* cookie保存在浏览器，session保存在服务器，session的安全性要大于cookie，通常使用Cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果有sessionid，服务器将根据该id返回对应Session对象。如果客户端请求中没有sessionid，服务器会创建新的Session对象，并把sessionid在本次响应中返回给客户端。
* session没有大小的限制



**接口调用的失败机制，重试机制，幂等机制**



**解决过的生产问题**



# 分布式



防止重复请求(幂等问题)

Hystrix 熔断原理，为什么用熔断

Feign 通信原理

负载均衡策略，以及Ribbon原理

zuul四种过滤器原理

注册中心Rureka流程解释

**SpringCloud限流用那个组件**

**什么是微服务**

**分布是的优点**

哪个用到的多哪个就多部署一点

**分布式的缺点**

1、架构设计变得复杂，事务不好处理（分布式事务）

2、部署服务复杂话，启动需要很久

3、系统的吞吐量会变大，但是响应时间会变长

5、架构复杂导致学习曲线变大

6、测试和查错的复杂度大，因为链路太长环境太多，需要花时间定位具体在什么服务上在物理在什么机器上

8、最麻烦的是消息不知道落地哪台机器上了，大公司有分布式日志框架来解决这个问题TraceID 

**分布的组件**

微服务有什么优缺点





# WEB



**session的实现方式(分布式session)**







# NET



**HTTP的状态码**

* 500
* 401
* 302



**为什么要进行三次握手和四次挥手，详细点**



**浏览器输入URL 整体流程-包括网络层、链路层、物理层**



**DNS解析原理**



# 设计模式



模板模式



**单例模式分类**

怎么实现单例设计模式，饿汉式，懒汉式



**模板模式**

模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。

使用场景

* 固定算法骨架
* 各个子类中有公共的部分
* 需要控制子类情况，扩展留给子类
* 一般Controller类某功能的增删改查

写好固定的处理逻辑



## 算法



**你知道的排序方法有哪些，时间复杂度**









































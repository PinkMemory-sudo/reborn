* 原子性

* 可见性

* 重入锁
* 锁对象
* 死锁
* 公平锁与非公平锁



原子性：

在操作数据前，先加上锁，完成后再释放锁



重入锁

重入锁使得同一个线程可以对同一把锁，在不释放的前提下，反复加锁，而不会导致线程卡死，唯一需要保证的就是lock和unlock的次数相同



# Lock





**ReentrantLock**



`void lock()`

获得锁，setting the lock hold count to one，别的线程已经获得锁时就一直等待



`boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException`

尝试获取锁，等待timeout时间。同时，可以响应中断。

* 不用无限等待，避免形成死锁。如果一段时间等不到锁，可以直接放弃，同时释放自己已经得到的资源。这样，就可以在很大程度上，避免死锁的产生。
* 等待锁的过程中可以响应中断，如果此时，程序正好收到关机信号，中断就会触发，进入中断异常后，线程就可以做一些清理工作，从而防止在终止程序时出现数据写坏，数据丢失等悲催的情况



`boolean tryLock()`

这个不带任何参数的tryLock()不会进行任何等待，如果能够获得锁，直接返回true，如果获取失败，就返回false，特别适合在应用层自己对锁进行管理，在应用层进行自旋等待。



`unlock`



释放锁



**可重入锁实现原理**

就是基于一个状态变量state，当这个state==0时，表示锁是空闲的，大于零表示锁已经被占用， 它的数值表示当前线程重复占用这个锁的次数。

对state进行CAS操作，如果成功就占用锁，如果发现锁就是当前线程占用的，则更新state，表示重复占用的次数



**CAS**



**公平锁与非公平锁**

可重入锁默认是非公平锁，即谁先拿到锁是随机的，如果想先到咸的，就需要在创建锁的时候执行为公平锁

`ReentrantLock fairLock = new ReentrantLock(true);`



## **Condition**



重入锁的伴生对象Condition提供了await()和singal()的功能，可以用于线程间消息通信





* 竞争与协作
* 互斥与同步



线程是调度的基本单位，进程则是资源分配的基本单位。所以线程之间可以共享进程的资源，但每个线程都有自己独立的栈空间。



线程的同步







**公平锁与非公平锁**

非公平锁：随机，倾向于再次让一个对象获得锁

公平锁：按照时间先后顺序，保证先到先得



**线程饥饿**














































































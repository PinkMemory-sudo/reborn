# 基础



**Redis的优缺点**

优点：

* 基于内存操作，内存读写速度快。

* 支持多种数据类型，包括String、Hash、List、Set、ZSet等。

* 支持持久化。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。

缺点：

1. 对结构化查询的支持比较差。
2. 数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。



**Redis为什么这么快**

* **基于内存**：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。

* **IO多路复用模型**：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。

* **高效的数据结构**：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度



**Redis常见数据类型和使用场景**

String：计数场景

set：存放不重复数据以及集合运算

sorted set：与set相比多了score字段，可以根据score字段进行排序

List：双向链表，消息队列，订阅模式

hash：对象存储

bitmap：位图只需要一个 bit 就可以表示一个元素的状态，极大的节省储存空间



**位图的使用场景**



**Redis的内存用完了会怎样**



**内存淘汰策略**

1. volatile-lru(least recently used):从已设置过期时间的数据集(server.db[i].expires) 中挑选最近最少使用的数据淘汰
2. volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
3. volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
4. allkeys-lru(least recently used):当内存不足以容纳新写入数据时，在键空间中，移除
   最近最少使用的 key(这个是最常用的)
5. allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰
6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报
   错。这个应该没人使用吧!



**过期了为什么内存没释放**





**一个字符串类型的值最大容量**

512M



**Redis 优点**

* 丰富的数据类型

* 持久化



# Redis使用场景



## 缓存

**缓存数据的处理流程是什么样的**

先查缓存，缓存中没有就去查数据库，查完后再更新到缓存



**为什么要使用redis做缓存**

不用去查询数据库，较少了数据库的压力，提高了 QPS



**缓存一致性问题**



**如何保证数据库与缓存的一致性**

强一致：

弱一致：

最终一致：

1. **旁路模式**

写：更新后直接删除cache

读：直接读缓存，没有读到时冲数据库中查并更新到缓存

**数据不一致产生的原因：**

* 先删除缓存，再更新 DB：可能还没更新好后又有请求来读，将旧的数据更新到了 cache 中
* 先更新 DB，再删除缓存：可能性小，比如刚开始没有缓存，请求A读取了 DB 还没更新到 Redis 时，请求B更新了 DB删除缓存，然后A 再讲读到的结果更新到 Redis，因为缓存的写入比数据库写入速度要快，这种情况可能很小

**强一致**

加锁，更新 DB 时更新 Redis，保证没有线程安全问题



2. **读写穿透**

把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。



3. 写流程





**缓存穿透**

去查询数据库中不存在的数据，这样缓存中找不到，每次都穿过缓存去查数据库。

解决方案：

首先需要鉴权，参数校验

1. 缓存无效的key：如果数据库和缓存中都没有，就将这个无效的key缓存起来，如果黑客构造了大量无效key会比较栈内存，所以key的有效期应该设置短些
2. 布隆过滤器：布隆过滤器说某个元素存在，某个元素可能小概率不存在，说某个元素不存咋，某个元素就一定不存在。

之后可以通过Nginx拉黑一些IP



**缓存击穿**

一个热key失效后同时有大量请求访问，导致数据库收到大量的请求

解决方案：

互斥锁



**缓存雪崩**

有些时候缓存是每天定时刷新的，就存在同一时间大量Key失效的情况，请求直接打到数据库上导致数据库宕机，重启之后又有大量请求进来又宕机。

解决方案：

1. 刷新缓存时添加一个随机时间
2. 热点数据永不过期，有更新时更新缓存



**位图**





# 持久化



**持久化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。



## RDB

RDB会定时将内存中的所有数据保存到dump.rdb文件中，重启时读取这个文件来恢复数据

**RDB持久化过程**：

创建子进程，父进程继续处理客户端请求，子进程将内存中的数据保存到临时文件中，然后再覆盖掉之前的RDB文件

默认持久化方式：RDB，一般将两者结合使用

**持久化时机**

1. 手动触发，SAVE或者shutdown命令
2. 每个多长时间或者有多少个键被修改

**优点**

恢复速度快

**缺点**

发生故障时，丢失的数据可能会多一点



## AOF

记录每次的写命令，重启后重新执行AOF文件中的命令来恢复数据

**开启AOF持久化**  `appendonly yes`

默认没30秒将缓冲中的命令刷新到磁盘

**重写机制**

```
# 每次
appendfync alwys
# 每秒
appendfsync everysec
# 不主动同步，把同步时机交给操作系统
appendfsync no
```



**同时**开启RDB和AOF，优先加载AOF文件，用RDB来做冷备份



# 线程



**Redis的线程模型**





Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件

Redis 基于Reactor 模式设计了自己的事件处理器，由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。



**单线程怎么监听大量客户端的连接**

Redis 通过**IO 多路复用程序** 来监听来自客户端的大量连接，或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。



**epoll**网络通信模型

一个线程处理多个客户端



更早的多路复用：select和poll



**事件驱动模型**



**Reactor**



**虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。



**单线程**

1. Redis 没有复杂的计算，性能瓶颈不在 CPU ，主要在内存和网络;
2. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能



**Redis6.0 后为何引入多线程**

Redis4 后就引入了多线程，主要用来异步执行一些比较耗时的操作，如删除大 key 等

Redis6.0 引入多线程主要实际上只是用来处理网络数据的读写和协议解析，执行命令仍然是单一工作线程，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程



Redis 的瓶颈受限于内存和网络



使用 I/O 多路复用技术能极大地减少系统的开销，系统不再需要为每个连接创建专门的监听线程，避免了由于大量的线程创建带来的巨大性能开销。

Redis将并发访问变成了串行进行，



内核空间与用户空间：在 Linux 中，应用程序稳定性远远比不上操作系统程序，为了保证操作系统的稳定性，Linux 区分了内核空间和用户空间。可以这样理解，内核空间运行操作系统程序和驱动程序，用户空间运行应用程序。Linux 以这种方式隔离了操作系统程序和应用程序，避免了应用程序影响到操作系统自身的稳定性。这也是 Linux 系统超级稳定的主要原因。所有的系统资源操作都在内核空间进行，比如读写磁盘文件，内存分配和回收，网络接口调用等。所以在一次网络 IO 读取过程中，数据并不是直接从网卡读取到用户空间中的应用程序缓冲区，而是先从网卡拷贝到内核空间缓冲区，然后再从内核拷贝到用户空间中的应用程序缓冲区。对于网络 IO 写入过程，过程则相反，先将数据从用户空间中的应用程序缓冲区拷贝到内核缓冲区，再从内核缓冲区把数据通过网卡发送出去。

-参考 [Redis6.0 为何引入多线程？单线程它不香吗？](https://blog.51cto.com/u_12351456/5080994)



# 集群



**redis有几种集群方案**



## 主从复制



目的：提高Redis负载能力



**同步机制原理**



## **哨兵原理**



**原理**

1.  每个Sentinel频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个PING命令。 
2.  如果一个实例（instance）距离最后一次有效回复PING命令的时间超过 own-after-milliseconds 选项所指定的值，则这个实例会被Sentinel标记为主观下线 。
3.  如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要确认Master的确进入了主观下线状态。 
4.  当有足够数量的Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态，则Master会被标记为客观下线。 
5.  旧Master会作为新Master的从机



**优先级**

1. 配置文件设置的优先级
2. 最大偏移量(最接近master的)
3. RunId



**集群之间如何复制**



**什么情况下会导致集群不可用**

hash槽不完整时



**Redis哈希槽的概念**

Redis中有16384个哈希槽，每个key根据算法计算出hash槽的位置，到对应的节点执行操作。



**Redis集群最大节点数**

16384



## Cluster



**涉及多个key的操作该怎么办**



**同步机制**

![image-20220124174153500](../img/redis同步机制.png)



**事务相关的命令有哪几个**

MULIT

EXEC

DISCARD

WATCH

通过MULIT开启事务，通过EXEC/DISCARD提交事务。



**实现乐观锁**





# 性能



**Redis 如何判断过期的**

Redis 中有一个字典保存着数据的过期时间，字典的键执行 Redis 中的某个 key，值时一个整数



# 热点



**Redis为什么使用单线程**



**Redis的多路复用**



**过期数据的删除策略**

1. 惰性删除 :只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会 造成太多过期 key 没有被删除。
2. 定期删除 : 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限 制删除操作执行的时⻓和频率来减少删除操作对CPU时间的影响。

Redis采用混合的模式







**如何保证Redis中都是日点数据**

淘汰策略？



## 如何保证数据一致性



# 其他



## 事务

事务的原理是将一个事务范围内的若干命令发送给Redis，然后再让Redis依次执行这些命令。

事务的生命周期：

1. 使用MULTI开启一个事务
2. 在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真的执行
3. EXEC命令进行提交事务

一个事务范围内某个命令出错不会影响其他命令的执行，**不保证原子性**



**事务与管道**



**Redis事务支持隔离性**

Redis 是单进程程序所以有隔离性，但是没有原子性。



设计一段程序，一分钟只能获得2次验证码



**利用Redis设计一个消息队列**

![image-20220124174604923](../img/redis实现MQ.png)

**写操作丢失**



**回收进程如何工作**

![image-20220124174927608](../img/Redis回收进程.png)



**回收使用的LRU算法**





**Redis内存模型**

![image-20220124182816566](../img/Redis内存模型.png)



## 分布式锁



### RedLock







## 主键

























































修改 value 后，key 的有效期变不变

inc一个不存在的 key 会不会异常





# 适用场景



一分钟一次验证码



一分钟三次验证码



一分钟内密码错误三次，锁定一小时



分布式锁



**集群中Session共享**

![image-20220124175227871](../img/Redis共享Session.png)






























































事务日志



# ACID

有些操作必须是原子性的，要成功都成功，要失败都失败，保证数据库的完整性。

**事务的四个特性**：

* 原子性(atomicity):一组SQL作为一个原子，要么都执行成功，要么都不执行
* 一致性(consistency):保证事务前后数据的合法性
* 隔离性(isolation):并发事务之间互不干扰
* 持久性(durability):事务一旦提交，对数据库中数据的修改就是永久性的



## ACID的原理



## 事务的隔离级别



# 事务的使用

**隐式事务**

INSERT、DELETE，UPDATE、SELECT都是隐式的事务，MySQL**默认开启了自动提交**。单条语句就会提交。



**显示事务**

关闭自动提交或者执行`start transaction/BEGIN`

1. 关闭自动提交`SET AUTOCOMMIT=0`（只是关闭了当前会话的自动提交）

2. 开启事务`start transaction/BEGIN` 
3. 执行SQL语句
4. 提交/回滚事务。COMMIT/ROLLBACK

SAVEPOINT

一个事务中可以有多个 SAVEPOINT,ROLLBACK TO identifier 把事务回滚到标记点。



**事务的隔离级别**

当多个事务同时使用数据库中相同的数据时，就可能会相互影响。	

***藏写***

事务A和事务B同时修改一个数据

***脏读***

事务T1读取到了事务T2还为提交的数据，当T2回滚时，T1读到的数据就是错误的

***不可重读***

不能重复读，重复读取到的两个值不一样。两个事务T1,T2,T1读取了一个字段的值，T2修改了该字段的值，T1再次读取该字段的值，会造成前后两个值不一致。

***幻读***

T1读取表中的字段进行统计，T2新增了记录并提交了事务，当T1在读取时就会**多出来几行**。与不可重读类似，不可重读时值变了，前后读取的值不相同。幻读时有新纪录插入，前后读取到的数量不同。

**不可重读与幻读**



MySQL支持四种隔离级别

`select  @@tx_isolation;`查看隔离级别	

| 级别                       | 解决了什么问题，还有什么问题         |
| -------------------------- | ------------------------------------ |
| 读取未提交READ UNCOMMITTED | 会导致读取未提交、不可重复读和幻读   |
| 读取已提交READ COMMITTED   | 避免了脏读脏写，会导致不可重读和幻读 |
| 可重复读REPEATABLE READ    | MySQL默认的，会导致幻读              |
| 串行化SERIALIZABLE         | 可以避免三个问题，但性能低           |

设置隔离级别

```mysql
SET TRANSACTION level;
```



**可重读下怎么解决幻读的**

InnoDB默认隔离级别树可重复度，使用Next-Key lock算法避免幻读的产生。



**串行读是怎么解决幻读的**

会隐式的添加行(X)锁/gap(X)锁



# redo log

* 保证事务的持久性

数据都是先读取到内存中进行修改，内存中的数据以一定的频率刷新到磁盘。



**为什么不直接刷新到磁盘**

1. 刷新到磁盘后事务才算成功，但随机IO比较慢，修改量与磁盘刷新量不成比例，就该一条数据起码要对一页(16kb)进行IO，效率低
2. 只将对数据库的修改保存起来，哪个地方进行什么修改，到达一定量后再刷新到磁盘，降低了IO频率



**checkpoint**

用来干嘛的



**redo log与bin log的区别**

* binlog 是一种逻辑日志，他里边所记录的是一条 SQL 语句的原始逻辑而redolog记录的是物理上哪个位置进行什么操作
* binlog 文件写满后，会自动切换到下一个日志文件继续写，redolog是循环写入的

**redolog buffer**



**redolog file**



**刷盘策略**

redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一定的频率 刷入到真正的redo log file 中。怎么刷盘可以通过`innodb_flush_log_at_trx_commit`设置

* 0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步）
* 1：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）
* 2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。



**redolog的流程**

1. 先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
2. 生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值
3. 当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式
4. 定期将内存中修改的数据刷新到磁盘中





# undo log

* 保证原子性和一致性
* 一致性非锁定读(MVCC)

更新数据前，实际是先将数据写入undolog，比如插入数据时，修改数据时，删除数据时，此外，undolog也需要redolog来保证undolog的持久性

**undolog只是逻辑上的恢复**，即物理存储不可能再恢复到和之前一模一样



# 事务 



# 锁



保证事务的隔离性。

并发事务访问相同的记录：

读读：互不影响

写写：两个事务同时进行写，

读写：



**死锁**





# MVCC
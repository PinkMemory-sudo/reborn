Redis



怎么做缓存

缓存数据的处理流程



分布式缓存



单线程模型



为什么不使用多线程



为什么又引入了多线程



Redis 是如何判断数据过期的



删除策略



淘汰策略



缓存穿透



雪崩



**如何保证缓存和数据库的一致性**







**缓存的三种读写策略**

旁路缓存模式(Cache Aside Pattern)

缺点：

* 首次请求的数据一定没有缓存
* 写操作频繁时缓存会频繁删除，影响缓存命中率



先删除缓存，再更新 DB

删除缓存后，还没有更新 DB 时去读数据，缓存中读不到就去读 DB 并更新到缓存中，之后 DB 在更新，造成数据不一致

先更新 DB，再删除缓存

小概率数据不一致，因为



解决方法：

更新 DB 的同时更新缓存，我们需要加锁/分布式锁保证更新缓存是不存在线程安全问题。

减少缓存的时间，短时间内允许缓存不一致



# Caffeine本地缓存

https://www.cnblogs.com/rickiyang/p/11074158.html











# 字符串



与 C 语言的字符串对比

除了字符数组，还保存了字符串的长度和字符数组空余的长度

* 提高了获得字符串长度的性能
* 杜绝了缓冲区溢出，修改字符串时，首先会判断剩余空间是否满足，空间不够会先扩展空间
* 减少了修改字符串带来的内存重分配，Redis 的空间预分配和空间惰性释放
* 二进制安全，Redis 数组采用字节数组，写入时什么样，读取就什么样，没有C 语言字符串的限制，如 C 语言空字符表示字符串结束，而 Reds 中可以包含空字符，它用 len 判断字符串的结尾

空间预分配：Redis中的字符数组≠字符串的长度+1，它会多分配一些，多余的长度记录为 free，当字符串长度增加时不用再重新分配内存

空间惰性删除：Redis字符串长度减少时，不会立即释放多余的空间，而是修改 free 的值，下次增加就不用重新分配内存

# 链表



list 的值保存在链表中，发布订阅，慢查询，监视器等功能也都使用到了链表

Redis 链表的实现

* 双端
* 无环
* 带头指针和为指针
* 带链长计数
* 多态：链表可以保存多种类型的值



# 字典



Redis 对数据库的增删改查都是基于字典操作的

Redis 中字典的实现

Redis 中使用哈希表来实现字典(数组+链表)

数组

```
数组
数组大小
哈希表大小掩码(数组长度-1)
已有节点的数量
```



**哈希算法**

添加新元素

1. 根据 key 算出哈希值和索引值
2. 将键值对放在指定索引上
3. 冲突时，新节点添加到表头(因为没有尾指针)



**rehash**

键值对太多或太少时，需要进行 rehash，调整哈希表的大小

**负载因子**



**渐进式 rehash**



# 跳跃表

有序集合建的底层实现

平均复杂度=

最坏复杂度

平衡树



跳跃表与红黑树，平衡数

跳表的查找、插入、删除的时间复杂度都是 O(logn)

java.util.concurrent 下的 ConcurrentSkipListMap()



https://www.jianshu.com/p/9d8296562806

空间换时间

一个有序的链表，抽出几个节点做索引，必要时再把这个索引抽出几个做二级索引

**过期键删除策略**

Redis 中有一个交错 expores 的字段，保存着过期键可时间

* 定时
* 惰性删除
* 定期



AOF，RDB 和复制功能对过期键的处理

过期的不会保存到 RDB

没有删除时会还在 AOF 中，删除后会追加 del 命令





# 持久化



Redis 是**事件驱动程序**，需要处理两类事件

文件事件

时间事件

**I/O多路复用**程序的实现





# 复制

心跳检测



# Sentinel



# 集群

**发布订阅**







**事务**

**管道**














































































































# 线程同步机制简介

​	从软件设计看，线程安全产生的原因是因为多线程多共享变量的操作缺乏同步机制。线程同步机制用来协调线程之间访问数据的机制。

​	Java提供的同步机制包括：锁，volatile，final，static以及相关的API(wait/notify等)



## 锁

​		线程安全问题是多线程并发访问共享数据，锁的做法是将并发操作转换成串行操作，一次只允许一个线程操作共享变量，操作共享变量需要先获得锁。

**临界区：**一个线程子获得锁之后释放锁之前执行的代码称为临界区。

**排他锁(互斥锁)：**一个锁同时只能本一个线程持有。



锁实现了对共享数据的安全访问，保障了线程的原子性可见性与有序性。

1. 原子性，通过锁的互斥性保证：一个锁只能被一个线程持有，拥有锁的线程才能执行临界区的代码，这使得临界区的代码一次只能被一个线程执行(即使它失去了CPU执行权，但是它依然拥有锁，所以临界区的代码不可分割)。
2. 可见性，锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着冲刷处理器缓存的动作，保证了自己和别的线程能看到最新的数据。
3. 有序性，写线程在临界区锁执行的在读线程锁执行的临界区看来像是完全按照源码读取的。



**使用锁保证线程安全的前提**：

1. 这些操作共享变量的线程必须使用同一把锁
2. 即使是读取共享变量也需要先获得锁



JVM把锁分成**内部锁**和**显示锁**两种，内部锁有Synchronized实现，显示锁通过java.concurrent.locks.Lock接口的实现类实现。



**可重入性：**Reentrancy，一个线程持有该锁的时候能不能再次申请该锁。

**锁的争用与调度：**内部锁是非公平锁，显示锁可以是公平的，也可以是非公平的

**锁的粒度：**一个锁可以保护的共享数据的数量大小




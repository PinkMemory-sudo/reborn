# 基础



**Redis常见数据类型和使用场景**

String：计数场景

List：双向链表，消息队列，订阅模式

hash：对象存储

set：存放不重复数据以及获得交集并集

sorted set：与set相比多了score字段，可以根据score字段进行排序



**一个字符串类型的值最大容量**

512M



**Redis 优点**

* 丰富的数据类型

* 持久化



# Redis使用场景



## 做缓存

**缓存数据的处理流程是什么样的**

先查缓存，缓存中没有就去查数据库，查完后再更新到缓存



**为什么要使用redis做缓存**

不用去查询数据库，较少了数据库的压力，提高了 QPS



**位图**





# 线程



Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件

Redis 基于Reactor 模式设计了自己的事件处理器，由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。



**单线程怎么监听大量客户端的连接**

Redis 通过**IO 多路复用程序** 来监听来自客户端的大量连接，或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。



**虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。



**单线程**

1. Redis 没有复杂的计算，性能瓶颈不在 CPU ，主要在内存和网络;
2. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能



**Redis6.0 后为何引入多线程**

Redis4 后就引入了多线程，主要用来异步执行一些比较耗时的操作，如删除大 key 等

Redis6.0 引入多线程主要实际上只是用来处理网络数据的读写和协议解析，执行命令仍然是单一工作线程，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程



Redis 的瓶颈受限于内存和网络



使用 I/O 多路复用技术能极大地减少系统的开销，系统不再需要为每个连接创建专门的监听线程，避免了由于大量的线程创建带来的巨大性能开销。

Redis将并发访问变成了串行进行，



内核空间与用户空间：在 Linux 中，应用程序稳定性远远比不上操作系统程序，为了保证操作系统的稳定性，Linux 区分了内核空间和用户空间。可以这样理解，内核空间运行操作系统程序和驱动程序，用户空间运行应用程序。Linux 以这种方式隔离了操作系统程序和应用程序，避免了应用程序影响到操作系统自身的稳定性。这也是 Linux 系统超级稳定的主要原因。所有的系统资源操作都在内核空间进行，比如读写磁盘文件，内存分配和回收，网络接口调用等。所以在一次网络 IO 读取过程中，数据并不是直接从网卡读取到用户空间中的应用程序缓冲区，而是先从网卡拷贝到内核空间缓冲区，然后再从内核拷贝到用户空间中的应用程序缓冲区。对于网络 IO 写入过程，过程则相反，先将数据从用户空间中的应用程序缓冲区拷贝到内核缓冲区，再从内核缓冲区把数据通过网卡发送出去。

-参考 [Redis6.0 为何引入多线程？单线程它不香吗？](https://blog.51cto.com/u_12351456/5080994)



# 集群



**redis有几种集群方案**



## 主从复制



**集群之间如何复制**



**什么情况下会导致集群不可用**

hash槽不完整时



**Redis哈希槽的概念**

Redis中有16384个哈希槽，每个key根据算法计算出hash槽的位置，到对应的节点执行操作。



**Redis集群最大节点数**

16384



## Cluster



**涉及多个key的操作该怎么办**



**分布式锁**





# 事务



**Redis中事务执行失败，后面的命令仍然会执行**



**同步机制**

![image-20220124174153500](../img/redis同步机制.png)



**事务相关的命令有哪几个**

MULIT

EXEC

DISCARD

WATCH

通过MULIT开启事务，通过EXEC/DISCARD提交事务。



**实现乐观锁**





# 性能



**Redis 如何判断过期的**

Redis 中有一个字典保存着数据的过期时间，字典的键执行 Redis 中的某个 key，值时一个整数



# 热点



**过期数据的删除策略**

1. 惰性删除 :只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会 造成太多过期 key 没有被删除。
2. 定期删除 : 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限 制删除操作执行的时⻓和频率来减少删除操作对CPU时间的影响。

Redis采用混合的模式



**内存淘汰策略**

1. volatile-lru(least recently used):从已设置过期时间的数据集(server.db[i].expires) 中挑选最近最少使用的数据淘汰
2. volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
3. volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
4. allkeys-lru(least recently used):当内存不足以容纳新写入数据时，在键空间中，移除
最近最少使用的 key(这个是最常用的)
5. allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰
6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报
    错。这个应该没人使用吧!

4.0 版本后增加以下两种：

1. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰
2. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key



**缓存穿透**

访问不存在的key，每次都穿过缓存去查数据库

解决方案：

首先需要参数校验

1. 缓存无效的key：如果数据库和缓存中都没有，就将这个无效的key缓存起来，如果黑客构造了大量无效key会比较栈内存，所以key的有效期应该设置短些
2. 布隆过滤器：布隆过滤器说某个元素存在，某个元素可能小概率不存在，说某个元素不存咋，某个元素就一定不存在。



**缓存击穿**





**缓存雪崩**

同一时间大量的key失效，请求全部打在了数据库上，可能直接导致数据库宕机。



**如何保证Redis中都是日点数据**

淘汰策略？



**集群中Session共享**

![image-20220124175227871](../img/Redis共享Session.png)



# 其他



设计一段程序，一分钟只能获得2次验证码



**利用Redis设计一个消息队列**

![image-20220124174604923](../img/redis实现MQ.png)

**写操作丢失**



**回收进程如何工作**

![image-20220124174927608](../img/Redis回收进程.png)



**回收使用的LRU算法**



**Redis的使用场景**

* session缓存
* 排行版，计数器



**Redis内存模型**

![image-20220124182816566](../img/Redis内存模型.png)



# 分布式锁



# 

就是要注意缓存穿透，击穿，雪崩的问题



**持久化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。



**如何保证数据库与缓存的一致性**

1. **旁路模式**

写：更新后直接删除cache

读：直接读缓存，没有读到时冲数据库中查并更新到缓存

**数据不一致产生的原因：**

* 先删除缓存，再更新 DB：可能还没更新好后又有请求来读，将旧的数据更新到了 cache 中
* 先更新 DB，在删除缓存：可能性小，比如刚开始没有缓存，请求A读取了 DB 还没更新到 Redis 时，请求B更新了 DB删除缓存，然后A 再讲读到的结果更新到 Redis，因为缓存的写入比数据库写入速度要快，这种情况可能很小

**强一致**

加锁，更新 DB 时更新 Redis，保证没有线程安全问题



2. **读写穿透**

把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。







**Redis 如何实现分布式锁**







# 布隆过滤器































